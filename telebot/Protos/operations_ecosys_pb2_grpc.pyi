"""
@generated by mypy-protobuf.  Do not edit manually!
isort:skip_file
"""
import abc
import google.protobuf.empty_pb2
import grpc
import iot_prototype_pb2
import operations_ecosys_pb2
import typing

class AdminServicesStub:
    """Note for updates:
    If the object fields should be updated, 
    fields that do not need to be updated can be blank.
    However, do note that enums and bools have default values, 
    hence enums and bools should always be filled.

    """
    def __init__(self, channel: grpc.Channel) -> None: ...
    AddUser: grpc.UnaryUnaryMultiCallable[
        operations_ecosys_pb2.FullUser,
        operations_ecosys_pb2.Response]
    """User"""

    UpdateUser: grpc.UnaryUnaryMultiCallable[
        operations_ecosys_pb2.User,
        operations_ecosys_pb2.Response]

    DeleteUser: grpc.UnaryUnaryMultiCallable[
        operations_ecosys_pb2.User,
        operations_ecosys_pb2.Response]

    FindUsers: grpc.UnaryStreamMultiCallable[
        operations_ecosys_pb2.UserQuery,
        operations_ecosys_pb2.UsersResponse]
    """TODO change user response to have user scoring and stuff"""

    AddClient: grpc.UnaryUnaryMultiCallable[
        operations_ecosys_pb2.Client,
        operations_ecosys_pb2.Response]
    """Client"""

    UpdateClient: grpc.UnaryUnaryMultiCallable[
        operations_ecosys_pb2.Client,
        operations_ecosys_pb2.Response]

    DeleteClient: grpc.UnaryUnaryMultiCallable[
        operations_ecosys_pb2.Client,
        operations_ecosys_pb2.Response]

    FindClients: grpc.UnaryStreamMultiCallable[
        operations_ecosys_pb2.ClientQuery,
        operations_ecosys_pb2.ClientResponse]

    GetWANonce: grpc.UnaryUnaryMultiCallable[
        operations_ecosys_pb2.User,
        operations_ecosys_pb2.ResponseNonce]
    """Security Related"""

    GetSecurityString: grpc.UnaryUnaryMultiCallable[
        operations_ecosys_pb2.User,
        operations_ecosys_pb2.SecurityStringResponse]

    AuthenticateUser: grpc.UnaryUnaryMultiCallable[
        operations_ecosys_pb2.LoginRequest,
        operations_ecosys_pb2.UserTokenResponse]

    GetRegistrationCode: grpc.UnaryUnaryMultiCallable[
        operations_ecosys_pb2.RegistrationCodeRequest,
        operations_ecosys_pb2.RegistrationCodeResponse]
    """Is this user or client?"""

    CheckRegistrationCode: grpc.UnaryUnaryMultiCallable[
        operations_ecosys_pb2.RegistrationCode,
        operations_ecosys_pb2.SecurityStringResponse]


class AdminServicesServicer(metaclass=abc.ABCMeta):
    """Note for updates:
    If the object fields should be updated, 
    fields that do not need to be updated can be blank.
    However, do note that enums and bools have default values, 
    hence enums and bools should always be filled.

    """
    @abc.abstractmethod
    def AddUser(self,
        request: operations_ecosys_pb2.FullUser,
        context: grpc.ServicerContext,
    ) -> operations_ecosys_pb2.Response:
        """User"""
        pass

    @abc.abstractmethod
    def UpdateUser(self,
        request: operations_ecosys_pb2.User,
        context: grpc.ServicerContext,
    ) -> operations_ecosys_pb2.Response: ...

    @abc.abstractmethod
    def DeleteUser(self,
        request: operations_ecosys_pb2.User,
        context: grpc.ServicerContext,
    ) -> operations_ecosys_pb2.Response: ...

    @abc.abstractmethod
    def FindUsers(self,
        request: operations_ecosys_pb2.UserQuery,
        context: grpc.ServicerContext,
    ) -> typing.Iterator[operations_ecosys_pb2.UsersResponse]:
        """TODO change user response to have user scoring and stuff"""
        pass

    @abc.abstractmethod
    def AddClient(self,
        request: operations_ecosys_pb2.Client,
        context: grpc.ServicerContext,
    ) -> operations_ecosys_pb2.Response:
        """Client"""
        pass

    @abc.abstractmethod
    def UpdateClient(self,
        request: operations_ecosys_pb2.Client,
        context: grpc.ServicerContext,
    ) -> operations_ecosys_pb2.Response: ...

    @abc.abstractmethod
    def DeleteClient(self,
        request: operations_ecosys_pb2.Client,
        context: grpc.ServicerContext,
    ) -> operations_ecosys_pb2.Response: ...

    @abc.abstractmethod
    def FindClients(self,
        request: operations_ecosys_pb2.ClientQuery,
        context: grpc.ServicerContext,
    ) -> typing.Iterator[operations_ecosys_pb2.ClientResponse]: ...

    @abc.abstractmethod
    def GetWANonce(self,
        request: operations_ecosys_pb2.User,
        context: grpc.ServicerContext,
    ) -> operations_ecosys_pb2.ResponseNonce:
        """Security Related"""
        pass

    @abc.abstractmethod
    def GetSecurityString(self,
        request: operations_ecosys_pb2.User,
        context: grpc.ServicerContext,
    ) -> operations_ecosys_pb2.SecurityStringResponse: ...

    @abc.abstractmethod
    def AuthenticateUser(self,
        request: operations_ecosys_pb2.LoginRequest,
        context: grpc.ServicerContext,
    ) -> operations_ecosys_pb2.UserTokenResponse: ...

    @abc.abstractmethod
    def GetRegistrationCode(self,
        request: operations_ecosys_pb2.RegistrationCodeRequest,
        context: grpc.ServicerContext,
    ) -> operations_ecosys_pb2.RegistrationCodeResponse:
        """Is this user or client?"""
        pass

    @abc.abstractmethod
    def CheckRegistrationCode(self,
        request: operations_ecosys_pb2.RegistrationCode,
        context: grpc.ServicerContext,
    ) -> operations_ecosys_pb2.SecurityStringResponse: ...


def add_AdminServicesServicer_to_server(servicer: AdminServicesServicer, server: grpc.Server) -> None: ...

class BroadcastServicesStub:
    def __init__(self, channel: grpc.Channel) -> None: ...
    AddBroadcast: grpc.UnaryUnaryMultiCallable[
        operations_ecosys_pb2.Broadcast,
        operations_ecosys_pb2.Response]

    UpdateBroadcast: grpc.UnaryUnaryMultiCallable[
        operations_ecosys_pb2.Broadcast,
        operations_ecosys_pb2.Response]
    """Note that this update does not update the broadcast's recipient's inner status 
    such as the acknowledgement or rejection status but only if the recipient 
    is part of the broadcast.
    """

    DeleteBroadcast: grpc.UnaryUnaryMultiCallable[
        operations_ecosys_pb2.Broadcast,
        operations_ecosys_pb2.Response]

    FindBroadcasts: grpc.UnaryStreamMultiCallable[
        operations_ecosys_pb2.BroadcastQuery,
        operations_ecosys_pb2.BroadcastResponse]

    UpdateBroadcastRecipient: grpc.UnaryUnaryMultiCallable[
        operations_ecosys_pb2.BroadcastRecipient,
        operations_ecosys_pb2.Response]
    """Updating of broadcast recipients"""


class BroadcastServicesServicer(metaclass=abc.ABCMeta):
    @abc.abstractmethod
    def AddBroadcast(self,
        request: operations_ecosys_pb2.Broadcast,
        context: grpc.ServicerContext,
    ) -> operations_ecosys_pb2.Response: ...

    @abc.abstractmethod
    def UpdateBroadcast(self,
        request: operations_ecosys_pb2.Broadcast,
        context: grpc.ServicerContext,
    ) -> operations_ecosys_pb2.Response:
        """Note that this update does not update the broadcast's recipient's inner status 
        such as the acknowledgement or rejection status but only if the recipient 
        is part of the broadcast.
        """
        pass

    @abc.abstractmethod
    def DeleteBroadcast(self,
        request: operations_ecosys_pb2.Broadcast,
        context: grpc.ServicerContext,
    ) -> operations_ecosys_pb2.Response: ...

    @abc.abstractmethod
    def FindBroadcasts(self,
        request: operations_ecosys_pb2.BroadcastQuery,
        context: grpc.ServicerContext,
    ) -> typing.Iterator[operations_ecosys_pb2.BroadcastResponse]: ...

    @abc.abstractmethod
    def UpdateBroadcastRecipient(self,
        request: operations_ecosys_pb2.BroadcastRecipient,
        context: grpc.ServicerContext,
    ) -> operations_ecosys_pb2.Response:
        """Updating of broadcast recipients"""
        pass


def add_BroadcastServicesServicer_to_server(servicer: BroadcastServicesServicer, server: grpc.Server) -> None: ...

class RosterServicesStub:
    def __init__(self, channel: grpc.Channel) -> None: ...
    AddRoster: grpc.UnaryUnaryMultiCallable[
        operations_ecosys_pb2.BulkRosters,
        operations_ecosys_pb2.Response]
    """Add multiple rosters for different AIFS at the same time"""

    UpdateRoster: grpc.UnaryUnaryMultiCallable[
        operations_ecosys_pb2.BulkRosters,
        operations_ecosys_pb2.Response]
    """Note that this update does not update the roster's guard's inner status 
    such as the acknowledgement or attended status but only if the guard 
    is part of the roster.
    """

    DeleteRoster: grpc.UnaryUnaryMultiCallable[
        operations_ecosys_pb2.Roster,
        operations_ecosys_pb2.Response]

    FindRosters: grpc.UnaryStreamMultiCallable[
        operations_ecosys_pb2.RosterQuery,
        operations_ecosys_pb2.RosterResponse]

    GetAvailableUsers: grpc.UnaryStreamMultiCallable[
        operations_ecosys_pb2.AvailabilityQuery,
        operations_ecosys_pb2.EmployeeEvaluationResponse]

    FindRosterAssignments: grpc.UnaryStreamMultiCallable[
        operations_ecosys_pb2.RosterQuery,
        operations_ecosys_pb2.RosterAssignmentResponse]
    """Specifically for the roster assignments"""

    UpdateRosterAssignment: grpc.UnaryUnaryMultiCallable[
        operations_ecosys_pb2.RosterAssignement,
        operations_ecosys_pb2.Response]
    """Updates the individual roster assignment"""


class RosterServicesServicer(metaclass=abc.ABCMeta):
    @abc.abstractmethod
    def AddRoster(self,
        request: operations_ecosys_pb2.BulkRosters,
        context: grpc.ServicerContext,
    ) -> operations_ecosys_pb2.Response:
        """Add multiple rosters for different AIFS at the same time"""
        pass

    @abc.abstractmethod
    def UpdateRoster(self,
        request: operations_ecosys_pb2.BulkRosters,
        context: grpc.ServicerContext,
    ) -> operations_ecosys_pb2.Response:
        """Note that this update does not update the roster's guard's inner status 
        such as the acknowledgement or attended status but only if the guard 
        is part of the roster.
        """
        pass

    @abc.abstractmethod
    def DeleteRoster(self,
        request: operations_ecosys_pb2.Roster,
        context: grpc.ServicerContext,
    ) -> operations_ecosys_pb2.Response: ...

    @abc.abstractmethod
    def FindRosters(self,
        request: operations_ecosys_pb2.RosterQuery,
        context: grpc.ServicerContext,
    ) -> typing.Iterator[operations_ecosys_pb2.RosterResponse]: ...

    @abc.abstractmethod
    def GetAvailableUsers(self,
        request: operations_ecosys_pb2.AvailabilityQuery,
        context: grpc.ServicerContext,
    ) -> typing.Iterator[operations_ecosys_pb2.EmployeeEvaluationResponse]: ...

    @abc.abstractmethod
    def FindRosterAssignments(self,
        request: operations_ecosys_pb2.RosterQuery,
        context: grpc.ServicerContext,
    ) -> typing.Iterator[operations_ecosys_pb2.RosterAssignmentResponse]:
        """Specifically for the roster assignments"""
        pass

    @abc.abstractmethod
    def UpdateRosterAssignment(self,
        request: operations_ecosys_pb2.RosterAssignement,
        context: grpc.ServicerContext,
    ) -> operations_ecosys_pb2.Response:
        """Updates the individual roster assignment"""
        pass


def add_RosterServicesServicer_to_server(servicer: RosterServicesServicer, server: grpc.Server) -> None: ...

class IncidentReportServicesStub:
    def __init__(self, channel: grpc.Channel) -> None: ...
    AddIncidentReport: grpc.UnaryUnaryMultiCallable[
        operations_ecosys_pb2.IncidentReport,
        operations_ecosys_pb2.Response]

    UpdateIncidentReport: grpc.UnaryUnaryMultiCallable[
        operations_ecosys_pb2.IncidentReport,
        operations_ecosys_pb2.Response]

    DeleteIncidentReport: grpc.UnaryUnaryMultiCallable[
        operations_ecosys_pb2.IncidentReport,
        operations_ecosys_pb2.Response]

    FindIncidentReports: grpc.UnaryStreamMultiCallable[
        operations_ecosys_pb2.IncidentReportQuery,
        operations_ecosys_pb2.IncidentReportResponse]


class IncidentReportServicesServicer(metaclass=abc.ABCMeta):
    @abc.abstractmethod
    def AddIncidentReport(self,
        request: operations_ecosys_pb2.IncidentReport,
        context: grpc.ServicerContext,
    ) -> operations_ecosys_pb2.Response: ...

    @abc.abstractmethod
    def UpdateIncidentReport(self,
        request: operations_ecosys_pb2.IncidentReport,
        context: grpc.ServicerContext,
    ) -> operations_ecosys_pb2.Response: ...

    @abc.abstractmethod
    def DeleteIncidentReport(self,
        request: operations_ecosys_pb2.IncidentReport,
        context: grpc.ServicerContext,
    ) -> operations_ecosys_pb2.Response: ...

    @abc.abstractmethod
    def FindIncidentReports(self,
        request: operations_ecosys_pb2.IncidentReportQuery,
        context: grpc.ServicerContext,
    ) -> typing.Iterator[operations_ecosys_pb2.IncidentReportResponse]: ...


def add_IncidentReportServicesServicer_to_server(servicer: IncidentReportServicesServicer, server: grpc.Server) -> None: ...

class CameraIotServicesStub:
    def __init__(self, channel: grpc.Channel) -> None: ...
    SetGateState: grpc.UnaryUnaryMultiCallable[
        iot_prototype_pb2.GateState,
        operations_ecosys_pb2.Response]

    GetIotState: grpc.UnaryStreamMultiCallable[
        google.protobuf.empty_pb2.Empty,
        operations_ecosys_pb2.CameraIotResponse]
    """Continuously provides the states of the gates, fire alarms and cpu temperature
    as well as the camera endpoints. 
    Responses are sent only when there is a change in state
    Upon connection, all states are sent for all locations are sent.
    """


class CameraIotServicesServicer(metaclass=abc.ABCMeta):
    @abc.abstractmethod
    def SetGateState(self,
        request: iot_prototype_pb2.GateState,
        context: grpc.ServicerContext,
    ) -> operations_ecosys_pb2.Response: ...

    @abc.abstractmethod
    def GetIotState(self,
        request: google.protobuf.empty_pb2.Empty,
        context: grpc.ServicerContext,
    ) -> typing.Iterator[operations_ecosys_pb2.CameraIotResponse]:
        """Continuously provides the states of the gates, fire alarms and cpu temperature
        as well as the camera endpoints. 
        Responses are sent only when there is a change in state
        Upon connection, all states are sent for all locations are sent.
        """
        pass


def add_CameraIotServicesServicer_to_server(servicer: CameraIotServicesServicer, server: grpc.Server) -> None: ...
