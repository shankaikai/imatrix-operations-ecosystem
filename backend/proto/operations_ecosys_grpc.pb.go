// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.2.0
// - protoc             v3.15.8
// source: proto/operations_ecosys.proto

package operations_ecosys

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// AdminServicesClient is the client API for AdminServices service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type AdminServicesClient interface {
	// User
	AddUser(ctx context.Context, in *User, opts ...grpc.CallOption) (*Response, error)
	UpdateUser(ctx context.Context, in *User, opts ...grpc.CallOption) (*Response, error)
	DeleteUser(ctx context.Context, in *User, opts ...grpc.CallOption) (*Response, error)
	// TODO change user response to have user scoring and stuff
	FindUsers(ctx context.Context, in *UserQuery, opts ...grpc.CallOption) (AdminServices_FindUsersClient, error)
	GetWANonce(ctx context.Context, in *User, opts ...grpc.CallOption) (*ResponseNonce, error)
	// Client
	AddClient(ctx context.Context, in *Client, opts ...grpc.CallOption) (*Response, error)
	UpdateClient(ctx context.Context, in *Client, opts ...grpc.CallOption) (*Response, error)
	DeleteClient(ctx context.Context, in *Client, opts ...grpc.CallOption) (*Response, error)
	FindClients(ctx context.Context, in *ClientQuery, opts ...grpc.CallOption) (AdminServices_FindClientsClient, error)
}

type adminServicesClient struct {
	cc grpc.ClientConnInterface
}

func NewAdminServicesClient(cc grpc.ClientConnInterface) AdminServicesClient {
	return &adminServicesClient{cc}
}

func (c *adminServicesClient) AddUser(ctx context.Context, in *User, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, "/operations_ecosys.AdminServices/AddUser", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *adminServicesClient) UpdateUser(ctx context.Context, in *User, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, "/operations_ecosys.AdminServices/UpdateUser", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *adminServicesClient) DeleteUser(ctx context.Context, in *User, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, "/operations_ecosys.AdminServices/DeleteUser", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *adminServicesClient) FindUsers(ctx context.Context, in *UserQuery, opts ...grpc.CallOption) (AdminServices_FindUsersClient, error) {
	stream, err := c.cc.NewStream(ctx, &AdminServices_ServiceDesc.Streams[0], "/operations_ecosys.AdminServices/FindUsers", opts...)
	if err != nil {
		return nil, err
	}
	x := &adminServicesFindUsersClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type AdminServices_FindUsersClient interface {
	Recv() (*UsersResponse, error)
	grpc.ClientStream
}

type adminServicesFindUsersClient struct {
	grpc.ClientStream
}

func (x *adminServicesFindUsersClient) Recv() (*UsersResponse, error) {
	m := new(UsersResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *adminServicesClient) GetWANonce(ctx context.Context, in *User, opts ...grpc.CallOption) (*ResponseNonce, error) {
	out := new(ResponseNonce)
	err := c.cc.Invoke(ctx, "/operations_ecosys.AdminServices/GetWANonce", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *adminServicesClient) AddClient(ctx context.Context, in *Client, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, "/operations_ecosys.AdminServices/AddClient", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *adminServicesClient) UpdateClient(ctx context.Context, in *Client, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, "/operations_ecosys.AdminServices/UpdateClient", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *adminServicesClient) DeleteClient(ctx context.Context, in *Client, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, "/operations_ecosys.AdminServices/DeleteClient", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *adminServicesClient) FindClients(ctx context.Context, in *ClientQuery, opts ...grpc.CallOption) (AdminServices_FindClientsClient, error) {
	stream, err := c.cc.NewStream(ctx, &AdminServices_ServiceDesc.Streams[1], "/operations_ecosys.AdminServices/FindClients", opts...)
	if err != nil {
		return nil, err
	}
	x := &adminServicesFindClientsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type AdminServices_FindClientsClient interface {
	Recv() (*ClientResponse, error)
	grpc.ClientStream
}

type adminServicesFindClientsClient struct {
	grpc.ClientStream
}

func (x *adminServicesFindClientsClient) Recv() (*ClientResponse, error) {
	m := new(ClientResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// AdminServicesServer is the server API for AdminServices service.
// All implementations must embed UnimplementedAdminServicesServer
// for forward compatibility
type AdminServicesServer interface {
	// User
	AddUser(context.Context, *User) (*Response, error)
	UpdateUser(context.Context, *User) (*Response, error)
	DeleteUser(context.Context, *User) (*Response, error)
	// TODO change user response to have user scoring and stuff
	FindUsers(*UserQuery, AdminServices_FindUsersServer) error
	GetWANonce(context.Context, *User) (*ResponseNonce, error)
	// Client
	AddClient(context.Context, *Client) (*Response, error)
	UpdateClient(context.Context, *Client) (*Response, error)
	DeleteClient(context.Context, *Client) (*Response, error)
	FindClients(*ClientQuery, AdminServices_FindClientsServer) error
	mustEmbedUnimplementedAdminServicesServer()
}

// UnimplementedAdminServicesServer must be embedded to have forward compatible implementations.
type UnimplementedAdminServicesServer struct {
}

func (UnimplementedAdminServicesServer) AddUser(context.Context, *User) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddUser not implemented")
}
func (UnimplementedAdminServicesServer) UpdateUser(context.Context, *User) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateUser not implemented")
}
func (UnimplementedAdminServicesServer) DeleteUser(context.Context, *User) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteUser not implemented")
}
func (UnimplementedAdminServicesServer) FindUsers(*UserQuery, AdminServices_FindUsersServer) error {
	return status.Errorf(codes.Unimplemented, "method FindUsers not implemented")
}
func (UnimplementedAdminServicesServer) GetWANonce(context.Context, *User) (*ResponseNonce, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetWANonce not implemented")
}
func (UnimplementedAdminServicesServer) AddClient(context.Context, *Client) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddClient not implemented")
}
func (UnimplementedAdminServicesServer) UpdateClient(context.Context, *Client) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateClient not implemented")
}
func (UnimplementedAdminServicesServer) DeleteClient(context.Context, *Client) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteClient not implemented")
}
func (UnimplementedAdminServicesServer) FindClients(*ClientQuery, AdminServices_FindClientsServer) error {
	return status.Errorf(codes.Unimplemented, "method FindClients not implemented")
}
func (UnimplementedAdminServicesServer) mustEmbedUnimplementedAdminServicesServer() {}

// UnsafeAdminServicesServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to AdminServicesServer will
// result in compilation errors.
type UnsafeAdminServicesServer interface {
	mustEmbedUnimplementedAdminServicesServer()
}

func RegisterAdminServicesServer(s grpc.ServiceRegistrar, srv AdminServicesServer) {
	s.RegisterService(&AdminServices_ServiceDesc, srv)
}

func _AdminServices_AddUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(User)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AdminServicesServer).AddUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/operations_ecosys.AdminServices/AddUser",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AdminServicesServer).AddUser(ctx, req.(*User))
	}
	return interceptor(ctx, in, info, handler)
}

func _AdminServices_UpdateUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(User)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AdminServicesServer).UpdateUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/operations_ecosys.AdminServices/UpdateUser",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AdminServicesServer).UpdateUser(ctx, req.(*User))
	}
	return interceptor(ctx, in, info, handler)
}

func _AdminServices_DeleteUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(User)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AdminServicesServer).DeleteUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/operations_ecosys.AdminServices/DeleteUser",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AdminServicesServer).DeleteUser(ctx, req.(*User))
	}
	return interceptor(ctx, in, info, handler)
}

func _AdminServices_FindUsers_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(UserQuery)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(AdminServicesServer).FindUsers(m, &adminServicesFindUsersServer{stream})
}

type AdminServices_FindUsersServer interface {
	Send(*UsersResponse) error
	grpc.ServerStream
}

type adminServicesFindUsersServer struct {
	grpc.ServerStream
}

func (x *adminServicesFindUsersServer) Send(m *UsersResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _AdminServices_GetWANonce_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(User)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AdminServicesServer).GetWANonce(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/operations_ecosys.AdminServices/GetWANonce",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AdminServicesServer).GetWANonce(ctx, req.(*User))
	}
	return interceptor(ctx, in, info, handler)
}

func _AdminServices_AddClient_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Client)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AdminServicesServer).AddClient(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/operations_ecosys.AdminServices/AddClient",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AdminServicesServer).AddClient(ctx, req.(*Client))
	}
	return interceptor(ctx, in, info, handler)
}

func _AdminServices_UpdateClient_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Client)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AdminServicesServer).UpdateClient(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/operations_ecosys.AdminServices/UpdateClient",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AdminServicesServer).UpdateClient(ctx, req.(*Client))
	}
	return interceptor(ctx, in, info, handler)
}

func _AdminServices_DeleteClient_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Client)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AdminServicesServer).DeleteClient(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/operations_ecosys.AdminServices/DeleteClient",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AdminServicesServer).DeleteClient(ctx, req.(*Client))
	}
	return interceptor(ctx, in, info, handler)
}

func _AdminServices_FindClients_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ClientQuery)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(AdminServicesServer).FindClients(m, &adminServicesFindClientsServer{stream})
}

type AdminServices_FindClientsServer interface {
	Send(*ClientResponse) error
	grpc.ServerStream
}

type adminServicesFindClientsServer struct {
	grpc.ServerStream
}

func (x *adminServicesFindClientsServer) Send(m *ClientResponse) error {
	return x.ServerStream.SendMsg(m)
}

// AdminServices_ServiceDesc is the grpc.ServiceDesc for AdminServices service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var AdminServices_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "operations_ecosys.AdminServices",
	HandlerType: (*AdminServicesServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AddUser",
			Handler:    _AdminServices_AddUser_Handler,
		},
		{
			MethodName: "UpdateUser",
			Handler:    _AdminServices_UpdateUser_Handler,
		},
		{
			MethodName: "DeleteUser",
			Handler:    _AdminServices_DeleteUser_Handler,
		},
		{
			MethodName: "GetWANonce",
			Handler:    _AdminServices_GetWANonce_Handler,
		},
		{
			MethodName: "AddClient",
			Handler:    _AdminServices_AddClient_Handler,
		},
		{
			MethodName: "UpdateClient",
			Handler:    _AdminServices_UpdateClient_Handler,
		},
		{
			MethodName: "DeleteClient",
			Handler:    _AdminServices_DeleteClient_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "FindUsers",
			Handler:       _AdminServices_FindUsers_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "FindClients",
			Handler:       _AdminServices_FindClients_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "proto/operations_ecosys.proto",
}

// BroadcastServicesClient is the client API for BroadcastServices service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type BroadcastServicesClient interface {
	AddBroadcast(ctx context.Context, in *Broadcast, opts ...grpc.CallOption) (*Response, error)
	// Note that this update does not update the broadcast's recipient's inner status
	// such as the acknowledgement or rejection status but only if the recipient
	// is part of the broadcast.
	UpdateBroadcast(ctx context.Context, in *Broadcast, opts ...grpc.CallOption) (*Response, error)
	DeleteBroadcast(ctx context.Context, in *Broadcast, opts ...grpc.CallOption) (*Response, error)
	FindBroadcasts(ctx context.Context, in *BroadcastQuery, opts ...grpc.CallOption) (BroadcastServices_FindBroadcastsClient, error)
	// Updating of broadcast recipients
	UpdateBroadcastRecipient(ctx context.Context, in *BroadcastRecipient, opts ...grpc.CallOption) (*Response, error)
}

type broadcastServicesClient struct {
	cc grpc.ClientConnInterface
}

func NewBroadcastServicesClient(cc grpc.ClientConnInterface) BroadcastServicesClient {
	return &broadcastServicesClient{cc}
}

func (c *broadcastServicesClient) AddBroadcast(ctx context.Context, in *Broadcast, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, "/operations_ecosys.BroadcastServices/AddBroadcast", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *broadcastServicesClient) UpdateBroadcast(ctx context.Context, in *Broadcast, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, "/operations_ecosys.BroadcastServices/UpdateBroadcast", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *broadcastServicesClient) DeleteBroadcast(ctx context.Context, in *Broadcast, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, "/operations_ecosys.BroadcastServices/DeleteBroadcast", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *broadcastServicesClient) FindBroadcasts(ctx context.Context, in *BroadcastQuery, opts ...grpc.CallOption) (BroadcastServices_FindBroadcastsClient, error) {
	stream, err := c.cc.NewStream(ctx, &BroadcastServices_ServiceDesc.Streams[0], "/operations_ecosys.BroadcastServices/FindBroadcasts", opts...)
	if err != nil {
		return nil, err
	}
	x := &broadcastServicesFindBroadcastsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type BroadcastServices_FindBroadcastsClient interface {
	Recv() (*BroadcastResponse, error)
	grpc.ClientStream
}

type broadcastServicesFindBroadcastsClient struct {
	grpc.ClientStream
}

func (x *broadcastServicesFindBroadcastsClient) Recv() (*BroadcastResponse, error) {
	m := new(BroadcastResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *broadcastServicesClient) UpdateBroadcastRecipient(ctx context.Context, in *BroadcastRecipient, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, "/operations_ecosys.BroadcastServices/UpdateBroadcastRecipient", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// BroadcastServicesServer is the server API for BroadcastServices service.
// All implementations must embed UnimplementedBroadcastServicesServer
// for forward compatibility
type BroadcastServicesServer interface {
	AddBroadcast(context.Context, *Broadcast) (*Response, error)
	// Note that this update does not update the broadcast's recipient's inner status
	// such as the acknowledgement or rejection status but only if the recipient
	// is part of the broadcast.
	UpdateBroadcast(context.Context, *Broadcast) (*Response, error)
	DeleteBroadcast(context.Context, *Broadcast) (*Response, error)
	FindBroadcasts(*BroadcastQuery, BroadcastServices_FindBroadcastsServer) error
	// Updating of broadcast recipients
	UpdateBroadcastRecipient(context.Context, *BroadcastRecipient) (*Response, error)
	mustEmbedUnimplementedBroadcastServicesServer()
}

// UnimplementedBroadcastServicesServer must be embedded to have forward compatible implementations.
type UnimplementedBroadcastServicesServer struct {
}

func (UnimplementedBroadcastServicesServer) AddBroadcast(context.Context, *Broadcast) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddBroadcast not implemented")
}
func (UnimplementedBroadcastServicesServer) UpdateBroadcast(context.Context, *Broadcast) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateBroadcast not implemented")
}
func (UnimplementedBroadcastServicesServer) DeleteBroadcast(context.Context, *Broadcast) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteBroadcast not implemented")
}
func (UnimplementedBroadcastServicesServer) FindBroadcasts(*BroadcastQuery, BroadcastServices_FindBroadcastsServer) error {
	return status.Errorf(codes.Unimplemented, "method FindBroadcasts not implemented")
}
func (UnimplementedBroadcastServicesServer) UpdateBroadcastRecipient(context.Context, *BroadcastRecipient) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateBroadcastRecipient not implemented")
}
func (UnimplementedBroadcastServicesServer) mustEmbedUnimplementedBroadcastServicesServer() {}

// UnsafeBroadcastServicesServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to BroadcastServicesServer will
// result in compilation errors.
type UnsafeBroadcastServicesServer interface {
	mustEmbedUnimplementedBroadcastServicesServer()
}

func RegisterBroadcastServicesServer(s grpc.ServiceRegistrar, srv BroadcastServicesServer) {
	s.RegisterService(&BroadcastServices_ServiceDesc, srv)
}

func _BroadcastServices_AddBroadcast_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Broadcast)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BroadcastServicesServer).AddBroadcast(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/operations_ecosys.BroadcastServices/AddBroadcast",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BroadcastServicesServer).AddBroadcast(ctx, req.(*Broadcast))
	}
	return interceptor(ctx, in, info, handler)
}

func _BroadcastServices_UpdateBroadcast_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Broadcast)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BroadcastServicesServer).UpdateBroadcast(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/operations_ecosys.BroadcastServices/UpdateBroadcast",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BroadcastServicesServer).UpdateBroadcast(ctx, req.(*Broadcast))
	}
	return interceptor(ctx, in, info, handler)
}

func _BroadcastServices_DeleteBroadcast_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Broadcast)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BroadcastServicesServer).DeleteBroadcast(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/operations_ecosys.BroadcastServices/DeleteBroadcast",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BroadcastServicesServer).DeleteBroadcast(ctx, req.(*Broadcast))
	}
	return interceptor(ctx, in, info, handler)
}

func _BroadcastServices_FindBroadcasts_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(BroadcastQuery)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(BroadcastServicesServer).FindBroadcasts(m, &broadcastServicesFindBroadcastsServer{stream})
}

type BroadcastServices_FindBroadcastsServer interface {
	Send(*BroadcastResponse) error
	grpc.ServerStream
}

type broadcastServicesFindBroadcastsServer struct {
	grpc.ServerStream
}

func (x *broadcastServicesFindBroadcastsServer) Send(m *BroadcastResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _BroadcastServices_UpdateBroadcastRecipient_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BroadcastRecipient)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BroadcastServicesServer).UpdateBroadcastRecipient(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/operations_ecosys.BroadcastServices/UpdateBroadcastRecipient",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BroadcastServicesServer).UpdateBroadcastRecipient(ctx, req.(*BroadcastRecipient))
	}
	return interceptor(ctx, in, info, handler)
}

// BroadcastServices_ServiceDesc is the grpc.ServiceDesc for BroadcastServices service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var BroadcastServices_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "operations_ecosys.BroadcastServices",
	HandlerType: (*BroadcastServicesServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AddBroadcast",
			Handler:    _BroadcastServices_AddBroadcast_Handler,
		},
		{
			MethodName: "UpdateBroadcast",
			Handler:    _BroadcastServices_UpdateBroadcast_Handler,
		},
		{
			MethodName: "DeleteBroadcast",
			Handler:    _BroadcastServices_DeleteBroadcast_Handler,
		},
		{
			MethodName: "UpdateBroadcastRecipient",
			Handler:    _BroadcastServices_UpdateBroadcastRecipient_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "FindBroadcasts",
			Handler:       _BroadcastServices_FindBroadcasts_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "proto/operations_ecosys.proto",
}

// RosterServicesClient is the client API for RosterServices service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type RosterServicesClient interface {
	// Add multiple rosters for different AIFS at the same time
	AddRoster(ctx context.Context, in *BulkRosters, opts ...grpc.CallOption) (*Response, error)
	// Note that this update does not update the roster's guard's inner status
	// such as the acknowledgement or attended status but only if the guard
	// is part of the roster.
	UpdateRoster(ctx context.Context, in *BulkRosters, opts ...grpc.CallOption) (*Response, error)
	DeleteRoster(ctx context.Context, in *Roster, opts ...grpc.CallOption) (*Response, error)
	FindRosters(ctx context.Context, in *RosterQuery, opts ...grpc.CallOption) (RosterServices_FindRostersClient, error)
	GetAvailableUsers(ctx context.Context, in *AvailabilityQuery, opts ...grpc.CallOption) (RosterServices_GetAvailableUsersClient, error)
	// Specifically for the roster assignments
	FindRosterAssignments(ctx context.Context, in *RosterQuery, opts ...grpc.CallOption) (RosterServices_FindRosterAssignmentsClient, error)
	// Updates the individual roster assignment
	UpdateRosterAssignment(ctx context.Context, in *RosterAssignement, opts ...grpc.CallOption) (*Response, error)
}

type rosterServicesClient struct {
	cc grpc.ClientConnInterface
}

func NewRosterServicesClient(cc grpc.ClientConnInterface) RosterServicesClient {
	return &rosterServicesClient{cc}
}

func (c *rosterServicesClient) AddRoster(ctx context.Context, in *BulkRosters, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, "/operations_ecosys.RosterServices/AddRoster", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rosterServicesClient) UpdateRoster(ctx context.Context, in *BulkRosters, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, "/operations_ecosys.RosterServices/UpdateRoster", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rosterServicesClient) DeleteRoster(ctx context.Context, in *Roster, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, "/operations_ecosys.RosterServices/DeleteRoster", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rosterServicesClient) FindRosters(ctx context.Context, in *RosterQuery, opts ...grpc.CallOption) (RosterServices_FindRostersClient, error) {
	stream, err := c.cc.NewStream(ctx, &RosterServices_ServiceDesc.Streams[0], "/operations_ecosys.RosterServices/FindRosters", opts...)
	if err != nil {
		return nil, err
	}
	x := &rosterServicesFindRostersClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type RosterServices_FindRostersClient interface {
	Recv() (*RosterResponse, error)
	grpc.ClientStream
}

type rosterServicesFindRostersClient struct {
	grpc.ClientStream
}

func (x *rosterServicesFindRostersClient) Recv() (*RosterResponse, error) {
	m := new(RosterResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *rosterServicesClient) GetAvailableUsers(ctx context.Context, in *AvailabilityQuery, opts ...grpc.CallOption) (RosterServices_GetAvailableUsersClient, error) {
	stream, err := c.cc.NewStream(ctx, &RosterServices_ServiceDesc.Streams[1], "/operations_ecosys.RosterServices/GetAvailableUsers", opts...)
	if err != nil {
		return nil, err
	}
	x := &rosterServicesGetAvailableUsersClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type RosterServices_GetAvailableUsersClient interface {
	Recv() (*EmployeeEvaluationResponse, error)
	grpc.ClientStream
}

type rosterServicesGetAvailableUsersClient struct {
	grpc.ClientStream
}

func (x *rosterServicesGetAvailableUsersClient) Recv() (*EmployeeEvaluationResponse, error) {
	m := new(EmployeeEvaluationResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *rosterServicesClient) FindRosterAssignments(ctx context.Context, in *RosterQuery, opts ...grpc.CallOption) (RosterServices_FindRosterAssignmentsClient, error) {
	stream, err := c.cc.NewStream(ctx, &RosterServices_ServiceDesc.Streams[2], "/operations_ecosys.RosterServices/FindRosterAssignments", opts...)
	if err != nil {
		return nil, err
	}
	x := &rosterServicesFindRosterAssignmentsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type RosterServices_FindRosterAssignmentsClient interface {
	Recv() (*RosterAssignmentResponse, error)
	grpc.ClientStream
}

type rosterServicesFindRosterAssignmentsClient struct {
	grpc.ClientStream
}

func (x *rosterServicesFindRosterAssignmentsClient) Recv() (*RosterAssignmentResponse, error) {
	m := new(RosterAssignmentResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *rosterServicesClient) UpdateRosterAssignment(ctx context.Context, in *RosterAssignement, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, "/operations_ecosys.RosterServices/UpdateRosterAssignment", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// RosterServicesServer is the server API for RosterServices service.
// All implementations must embed UnimplementedRosterServicesServer
// for forward compatibility
type RosterServicesServer interface {
	// Add multiple rosters for different AIFS at the same time
	AddRoster(context.Context, *BulkRosters) (*Response, error)
	// Note that this update does not update the roster's guard's inner status
	// such as the acknowledgement or attended status but only if the guard
	// is part of the roster.
	UpdateRoster(context.Context, *BulkRosters) (*Response, error)
	DeleteRoster(context.Context, *Roster) (*Response, error)
	FindRosters(*RosterQuery, RosterServices_FindRostersServer) error
	GetAvailableUsers(*AvailabilityQuery, RosterServices_GetAvailableUsersServer) error
	// Specifically for the roster assignments
	FindRosterAssignments(*RosterQuery, RosterServices_FindRosterAssignmentsServer) error
	// Updates the individual roster assignment
	UpdateRosterAssignment(context.Context, *RosterAssignement) (*Response, error)
	mustEmbedUnimplementedRosterServicesServer()
}

// UnimplementedRosterServicesServer must be embedded to have forward compatible implementations.
type UnimplementedRosterServicesServer struct {
}

func (UnimplementedRosterServicesServer) AddRoster(context.Context, *BulkRosters) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddRoster not implemented")
}
func (UnimplementedRosterServicesServer) UpdateRoster(context.Context, *BulkRosters) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateRoster not implemented")
}
func (UnimplementedRosterServicesServer) DeleteRoster(context.Context, *Roster) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteRoster not implemented")
}
func (UnimplementedRosterServicesServer) FindRosters(*RosterQuery, RosterServices_FindRostersServer) error {
	return status.Errorf(codes.Unimplemented, "method FindRosters not implemented")
}
func (UnimplementedRosterServicesServer) GetAvailableUsers(*AvailabilityQuery, RosterServices_GetAvailableUsersServer) error {
	return status.Errorf(codes.Unimplemented, "method GetAvailableUsers not implemented")
}
func (UnimplementedRosterServicesServer) FindRosterAssignments(*RosterQuery, RosterServices_FindRosterAssignmentsServer) error {
	return status.Errorf(codes.Unimplemented, "method FindRosterAssignments not implemented")
}
func (UnimplementedRosterServicesServer) UpdateRosterAssignment(context.Context, *RosterAssignement) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateRosterAssignment not implemented")
}
func (UnimplementedRosterServicesServer) mustEmbedUnimplementedRosterServicesServer() {}

// UnsafeRosterServicesServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to RosterServicesServer will
// result in compilation errors.
type UnsafeRosterServicesServer interface {
	mustEmbedUnimplementedRosterServicesServer()
}

func RegisterRosterServicesServer(s grpc.ServiceRegistrar, srv RosterServicesServer) {
	s.RegisterService(&RosterServices_ServiceDesc, srv)
}

func _RosterServices_AddRoster_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BulkRosters)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RosterServicesServer).AddRoster(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/operations_ecosys.RosterServices/AddRoster",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RosterServicesServer).AddRoster(ctx, req.(*BulkRosters))
	}
	return interceptor(ctx, in, info, handler)
}

func _RosterServices_UpdateRoster_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BulkRosters)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RosterServicesServer).UpdateRoster(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/operations_ecosys.RosterServices/UpdateRoster",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RosterServicesServer).UpdateRoster(ctx, req.(*BulkRosters))
	}
	return interceptor(ctx, in, info, handler)
}

func _RosterServices_DeleteRoster_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Roster)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RosterServicesServer).DeleteRoster(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/operations_ecosys.RosterServices/DeleteRoster",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RosterServicesServer).DeleteRoster(ctx, req.(*Roster))
	}
	return interceptor(ctx, in, info, handler)
}

func _RosterServices_FindRosters_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(RosterQuery)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(RosterServicesServer).FindRosters(m, &rosterServicesFindRostersServer{stream})
}

type RosterServices_FindRostersServer interface {
	Send(*RosterResponse) error
	grpc.ServerStream
}

type rosterServicesFindRostersServer struct {
	grpc.ServerStream
}

func (x *rosterServicesFindRostersServer) Send(m *RosterResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _RosterServices_GetAvailableUsers_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(AvailabilityQuery)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(RosterServicesServer).GetAvailableUsers(m, &rosterServicesGetAvailableUsersServer{stream})
}

type RosterServices_GetAvailableUsersServer interface {
	Send(*EmployeeEvaluationResponse) error
	grpc.ServerStream
}

type rosterServicesGetAvailableUsersServer struct {
	grpc.ServerStream
}

func (x *rosterServicesGetAvailableUsersServer) Send(m *EmployeeEvaluationResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _RosterServices_FindRosterAssignments_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(RosterQuery)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(RosterServicesServer).FindRosterAssignments(m, &rosterServicesFindRosterAssignmentsServer{stream})
}

type RosterServices_FindRosterAssignmentsServer interface {
	Send(*RosterAssignmentResponse) error
	grpc.ServerStream
}

type rosterServicesFindRosterAssignmentsServer struct {
	grpc.ServerStream
}

func (x *rosterServicesFindRosterAssignmentsServer) Send(m *RosterAssignmentResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _RosterServices_UpdateRosterAssignment_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RosterAssignement)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RosterServicesServer).UpdateRosterAssignment(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/operations_ecosys.RosterServices/UpdateRosterAssignment",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RosterServicesServer).UpdateRosterAssignment(ctx, req.(*RosterAssignement))
	}
	return interceptor(ctx, in, info, handler)
}

// RosterServices_ServiceDesc is the grpc.ServiceDesc for RosterServices service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var RosterServices_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "operations_ecosys.RosterServices",
	HandlerType: (*RosterServicesServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AddRoster",
			Handler:    _RosterServices_AddRoster_Handler,
		},
		{
			MethodName: "UpdateRoster",
			Handler:    _RosterServices_UpdateRoster_Handler,
		},
		{
			MethodName: "DeleteRoster",
			Handler:    _RosterServices_DeleteRoster_Handler,
		},
		{
			MethodName: "UpdateRosterAssignment",
			Handler:    _RosterServices_UpdateRosterAssignment_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "FindRosters",
			Handler:       _RosterServices_FindRosters_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "GetAvailableUsers",
			Handler:       _RosterServices_GetAvailableUsers_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "FindRosterAssignments",
			Handler:       _RosterServices_FindRosterAssignments_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "proto/operations_ecosys.proto",
}

// IncidentReportServicesClient is the client API for IncidentReportServices service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type IncidentReportServicesClient interface {
	AddIncidentReport(ctx context.Context, in *IncidentReport, opts ...grpc.CallOption) (*Response, error)
	UpdateIncidentReport(ctx context.Context, in *IncidentReport, opts ...grpc.CallOption) (*Response, error)
	DeleteIncidentReport(ctx context.Context, in *IncidentReport, opts ...grpc.CallOption) (*Response, error)
	FindIncidentReports(ctx context.Context, in *IncidentReportQuery, opts ...grpc.CallOption) (IncidentReportServices_FindIncidentReportsClient, error)
}

type incidentReportServicesClient struct {
	cc grpc.ClientConnInterface
}

func NewIncidentReportServicesClient(cc grpc.ClientConnInterface) IncidentReportServicesClient {
	return &incidentReportServicesClient{cc}
}

func (c *incidentReportServicesClient) AddIncidentReport(ctx context.Context, in *IncidentReport, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, "/operations_ecosys.IncidentReportServices/AddIncidentReport", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *incidentReportServicesClient) UpdateIncidentReport(ctx context.Context, in *IncidentReport, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, "/operations_ecosys.IncidentReportServices/UpdateIncidentReport", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *incidentReportServicesClient) DeleteIncidentReport(ctx context.Context, in *IncidentReport, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, "/operations_ecosys.IncidentReportServices/DeleteIncidentReport", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *incidentReportServicesClient) FindIncidentReports(ctx context.Context, in *IncidentReportQuery, opts ...grpc.CallOption) (IncidentReportServices_FindIncidentReportsClient, error) {
	stream, err := c.cc.NewStream(ctx, &IncidentReportServices_ServiceDesc.Streams[0], "/operations_ecosys.IncidentReportServices/FindIncidentReports", opts...)
	if err != nil {
		return nil, err
	}
	x := &incidentReportServicesFindIncidentReportsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type IncidentReportServices_FindIncidentReportsClient interface {
	Recv() (*IncidentReportResponse, error)
	grpc.ClientStream
}

type incidentReportServicesFindIncidentReportsClient struct {
	grpc.ClientStream
}

func (x *incidentReportServicesFindIncidentReportsClient) Recv() (*IncidentReportResponse, error) {
	m := new(IncidentReportResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// IncidentReportServicesServer is the server API for IncidentReportServices service.
// All implementations must embed UnimplementedIncidentReportServicesServer
// for forward compatibility
type IncidentReportServicesServer interface {
	AddIncidentReport(context.Context, *IncidentReport) (*Response, error)
	UpdateIncidentReport(context.Context, *IncidentReport) (*Response, error)
	DeleteIncidentReport(context.Context, *IncidentReport) (*Response, error)
	FindIncidentReports(*IncidentReportQuery, IncidentReportServices_FindIncidentReportsServer) error
	mustEmbedUnimplementedIncidentReportServicesServer()
}

// UnimplementedIncidentReportServicesServer must be embedded to have forward compatible implementations.
type UnimplementedIncidentReportServicesServer struct {
}

func (UnimplementedIncidentReportServicesServer) AddIncidentReport(context.Context, *IncidentReport) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddIncidentReport not implemented")
}
func (UnimplementedIncidentReportServicesServer) UpdateIncidentReport(context.Context, *IncidentReport) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateIncidentReport not implemented")
}
func (UnimplementedIncidentReportServicesServer) DeleteIncidentReport(context.Context, *IncidentReport) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteIncidentReport not implemented")
}
func (UnimplementedIncidentReportServicesServer) FindIncidentReports(*IncidentReportQuery, IncidentReportServices_FindIncidentReportsServer) error {
	return status.Errorf(codes.Unimplemented, "method FindIncidentReports not implemented")
}
func (UnimplementedIncidentReportServicesServer) mustEmbedUnimplementedIncidentReportServicesServer() {
}

// UnsafeIncidentReportServicesServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to IncidentReportServicesServer will
// result in compilation errors.
type UnsafeIncidentReportServicesServer interface {
	mustEmbedUnimplementedIncidentReportServicesServer()
}

func RegisterIncidentReportServicesServer(s grpc.ServiceRegistrar, srv IncidentReportServicesServer) {
	s.RegisterService(&IncidentReportServices_ServiceDesc, srv)
}

func _IncidentReportServices_AddIncidentReport_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IncidentReport)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IncidentReportServicesServer).AddIncidentReport(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/operations_ecosys.IncidentReportServices/AddIncidentReport",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IncidentReportServicesServer).AddIncidentReport(ctx, req.(*IncidentReport))
	}
	return interceptor(ctx, in, info, handler)
}

func _IncidentReportServices_UpdateIncidentReport_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IncidentReport)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IncidentReportServicesServer).UpdateIncidentReport(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/operations_ecosys.IncidentReportServices/UpdateIncidentReport",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IncidentReportServicesServer).UpdateIncidentReport(ctx, req.(*IncidentReport))
	}
	return interceptor(ctx, in, info, handler)
}

func _IncidentReportServices_DeleteIncidentReport_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IncidentReport)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IncidentReportServicesServer).DeleteIncidentReport(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/operations_ecosys.IncidentReportServices/DeleteIncidentReport",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IncidentReportServicesServer).DeleteIncidentReport(ctx, req.(*IncidentReport))
	}
	return interceptor(ctx, in, info, handler)
}

func _IncidentReportServices_FindIncidentReports_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(IncidentReportQuery)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(IncidentReportServicesServer).FindIncidentReports(m, &incidentReportServicesFindIncidentReportsServer{stream})
}

type IncidentReportServices_FindIncidentReportsServer interface {
	Send(*IncidentReportResponse) error
	grpc.ServerStream
}

type incidentReportServicesFindIncidentReportsServer struct {
	grpc.ServerStream
}

func (x *incidentReportServicesFindIncidentReportsServer) Send(m *IncidentReportResponse) error {
	return x.ServerStream.SendMsg(m)
}

// IncidentReportServices_ServiceDesc is the grpc.ServiceDesc for IncidentReportServices service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var IncidentReportServices_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "operations_ecosys.IncidentReportServices",
	HandlerType: (*IncidentReportServicesServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AddIncidentReport",
			Handler:    _IncidentReportServices_AddIncidentReport_Handler,
		},
		{
			MethodName: "UpdateIncidentReport",
			Handler:    _IncidentReportServices_UpdateIncidentReport_Handler,
		},
		{
			MethodName: "DeleteIncidentReport",
			Handler:    _IncidentReportServices_DeleteIncidentReport_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "FindIncidentReports",
			Handler:       _IncidentReportServices_FindIncidentReports_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "proto/operations_ecosys.proto",
}

// CameraIotServicesClient is the client API for CameraIotServices service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type CameraIotServicesClient interface {
	SetGateState(ctx context.Context, in *GateState, opts ...grpc.CallOption) (*Response, error)
	// Continuously provides the states of the gates, fire alarms and cpu temperature
	// as well as the camera endpoints.
	// Responses are sent only when there is a change in state
	// Upon connection, all states are sent for all locations are sent.
	GetIotState(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (CameraIotServices_GetIotStateClient, error)
}

type cameraIotServicesClient struct {
	cc grpc.ClientConnInterface
}

func NewCameraIotServicesClient(cc grpc.ClientConnInterface) CameraIotServicesClient {
	return &cameraIotServicesClient{cc}
}

func (c *cameraIotServicesClient) SetGateState(ctx context.Context, in *GateState, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, "/operations_ecosys.CameraIotServices/SetGateState", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cameraIotServicesClient) GetIotState(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (CameraIotServices_GetIotStateClient, error) {
	stream, err := c.cc.NewStream(ctx, &CameraIotServices_ServiceDesc.Streams[0], "/operations_ecosys.CameraIotServices/GetIotState", opts...)
	if err != nil {
		return nil, err
	}
	x := &cameraIotServicesGetIotStateClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type CameraIotServices_GetIotStateClient interface {
	Recv() (*CameraIotResponse, error)
	grpc.ClientStream
}

type cameraIotServicesGetIotStateClient struct {
	grpc.ClientStream
}

func (x *cameraIotServicesGetIotStateClient) Recv() (*CameraIotResponse, error) {
	m := new(CameraIotResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// CameraIotServicesServer is the server API for CameraIotServices service.
// All implementations must embed UnimplementedCameraIotServicesServer
// for forward compatibility
type CameraIotServicesServer interface {
	SetGateState(context.Context, *GateState) (*Response, error)
	// Continuously provides the states of the gates, fire alarms and cpu temperature
	// as well as the camera endpoints.
	// Responses are sent only when there is a change in state
	// Upon connection, all states are sent for all locations are sent.
	GetIotState(*emptypb.Empty, CameraIotServices_GetIotStateServer) error
	mustEmbedUnimplementedCameraIotServicesServer()
}

// UnimplementedCameraIotServicesServer must be embedded to have forward compatible implementations.
type UnimplementedCameraIotServicesServer struct {
}

func (UnimplementedCameraIotServicesServer) SetGateState(context.Context, *GateState) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetGateState not implemented")
}
func (UnimplementedCameraIotServicesServer) GetIotState(*emptypb.Empty, CameraIotServices_GetIotStateServer) error {
	return status.Errorf(codes.Unimplemented, "method GetIotState not implemented")
}
func (UnimplementedCameraIotServicesServer) mustEmbedUnimplementedCameraIotServicesServer() {}

// UnsafeCameraIotServicesServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to CameraIotServicesServer will
// result in compilation errors.
type UnsafeCameraIotServicesServer interface {
	mustEmbedUnimplementedCameraIotServicesServer()
}

func RegisterCameraIotServicesServer(s grpc.ServiceRegistrar, srv CameraIotServicesServer) {
	s.RegisterService(&CameraIotServices_ServiceDesc, srv)
}

func _CameraIotServices_SetGateState_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GateState)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CameraIotServicesServer).SetGateState(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/operations_ecosys.CameraIotServices/SetGateState",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CameraIotServicesServer).SetGateState(ctx, req.(*GateState))
	}
	return interceptor(ctx, in, info, handler)
}

func _CameraIotServices_GetIotState_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(emptypb.Empty)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(CameraIotServicesServer).GetIotState(m, &cameraIotServicesGetIotStateServer{stream})
}

type CameraIotServices_GetIotStateServer interface {
	Send(*CameraIotResponse) error
	grpc.ServerStream
}

type cameraIotServicesGetIotStateServer struct {
	grpc.ServerStream
}

func (x *cameraIotServicesGetIotStateServer) Send(m *CameraIotResponse) error {
	return x.ServerStream.SendMsg(m)
}

// CameraIotServices_ServiceDesc is the grpc.ServiceDesc for CameraIotServices service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var CameraIotServices_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "operations_ecosys.CameraIotServices",
	HandlerType: (*CameraIotServicesServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "SetGateState",
			Handler:    _CameraIotServices_SetGateState_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "GetIotState",
			Handler:       _CameraIotServices_GetIotState_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "proto/operations_ecosys.proto",
}
